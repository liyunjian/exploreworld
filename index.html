<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPXè½¨è¿¹æ¢ç´¢åœ°å›¾</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
    <style>
        * {
            box-sizing: border-box;
        }
        
        body { 
            margin: 0; 
            padding: 0; 
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        #map { 
            width: 100vw; 
            height: 100vh; 
            margin: 0; 
            padding: 0; 
        }
        
        #legend-card {
            position: absolute;
            top: max(20px, env(safe-area-inset-top, 0px) + 10px);
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            background: linear-gradient(145deg, rgba(30, 30, 35, 0.85) 0%, rgba(15, 15, 20, 0.9) 100%);
            backdrop-filter: blur(16px) saturate(180%);
            -webkit-backdrop-filter: blur(16px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.3), 
                        0 0 0 1px rgba(255, 255, 255, 0.05) inset;
            padding: 12px 24px 14px 24px;
            max-width: calc(96vw - 20px);
            min-width: min(420px, calc(100vw - 40px));
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: all 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
        }
        
        #legend-card:hover {
            transform: translateX(-50%) translateY(-4px) scale(1.02);
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.4),
                        0 0 0 1px rgba(255, 255, 255, 0.1) inset,
                        0 0 60px rgba(118, 56, 255, 0.3);
        }
        
        #legend-title {
            font-size: 1.5em;
            font-weight: 600;
            color: #e5e7eb;
            letter-spacing: -0.01em;
            line-height: 0.9;
            margin-bottom: 8px;
            text-align: center;
            text-shadow: 0 2px 10px rgba(0,0,0,0.5);
        }
        
        #legend-title span {
            font-weight: 700;
            font-size: 1.15em;
            background: linear-gradient(90deg, #818cf8, #c084fc, #f472b6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradient-flow 5s ease infinite;
            background-size: 200% auto;
        }
        
        @keyframes gradient-flow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        #legend {
            width: 100%;
            display: flex;
            gap: 20px;
            align-items: center;
            justify-content: center;
            flex-wrap: nowrap;
        }
        
        #legend span {
            white-space: nowrap;
            font-size: 14px;
            font-weight: 500;
            color: #d1d5db;
            flex: 0 0 auto;
        }
        
        /* è¿”å›ä¸»é¡µæŒ‰é’®æ ·å¼ */
        #home-button {
            position: absolute;
            top: max(20px, env(safe-area-inset-top, 0px) + 10px);
            left: max(20px, env(safe-area-inset-left, 0px) + 10px);
            z-index: 15;
            background: linear-gradient(145deg, rgba(30, 30, 35, 0.9) 0%, rgba(15, 15, 20, 0.95) 100%);
            backdrop-filter: blur(16px) saturate(180%);
            -webkit-backdrop-filter: blur(16px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 8px 12px;
            text-decoration: none;
            color: #e5e7eb;
            font-size: 12px;
            font-weight: 500;
            font-family: 'Inter', sans-serif;
            transition: all 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3),
                        0 0 0 1px rgba(255, 255, 255, 0.05) inset;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            text-align: center;
        }
        
        #home-button:hover {
            transform: translateY(-2px) scale(1.05);
            background: linear-gradient(145deg, rgba(40, 40, 50, 0.95) 0%, rgba(25, 25, 35, 1) 100%);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4),
                        0 0 0 1px rgba(255, 255, 255, 0.1) inset,
                        0 0 30px rgba(99, 102, 241, 0.3);
            color: #ffffff;
        }
        
        #home-button:active {
            transform: translateY(-1px) scale(1.02);
        }
        
        #home-button::before {
            content: "ğŸ ";
            font-size: 18px;
            line-height: 1;
        }
        
        #legend span:hover {
            color: #fff;
            text-shadow: 0 0 8px rgba(255,255,255,0.5);
        }
        
        #legend span > span {
            width: 18px;
            height: 4px;
            border-radius: 2px;
            margin-right: 8px;
            display: inline-block;
            box-shadow: 0 0 8px 1px var(--glow-color, transparent), 
                        0 0 4px var(--glow-color-2, transparent);
            transition: all 0.3s ease;
        }
        
        #legend span:hover > span {
            transform: scale(1.1);
            filter: brightness(1.2);
        }
        
        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 900px) and (min-width: 601px) {
            #legend-card {
                min-width: min(340px, calc(100vw - 40px));
                padding: 8px 16px 10px 16px;
                border-radius: 14px;
            }
            #legend-title {
                font-size: 1.2em;
                margin-bottom: 6px;
            }
            #legend {
                gap: 16px;
            }
            #legend span {
                font-size: 13px;
            }
            #legend span > span {
                width: 16px;
                height: 4px;
                margin-right: 8px;
                display: inline-block;
            }
            
            /* ä¸­ç­‰å±å¹•ä¸Šè¿”å›ä¸»é¡µæŒ‰é’®ç¨å¾®ç¼©å° */
            #home-button {
                padding: 6px 10px;
                font-size: 11px;
            }
            
            #home-button::before {
                font-size: 16px;
            }
        }
        
        @media (max-width: 600px) {
            #legend-card {
                min-width: min(280px, calc(100vw - 40px));
                padding: 6px 10px 8px 10px;
                border-radius: 12px;
                margin: 0 10px;
            }
            #legend-title {
                font-size: 1.0em;
                margin-bottom: 4px;
            }
            #legend {
                gap: 12px;
                flex-wrap: nowrap;
            }
            #legend span {
                font-size: 11px;
                display: flex;
                align-items: center;
            }
            #legend span > span {
                width: 14px;
                height: 3px;
                margin-right: 6px;
                display: inline-block;
                flex-shrink: 0;
            }
            
            /* æ‰‹æœºä¸Šè¿”å›ä¸»é¡µæŒ‰é’®æ˜¾è‘—ç¼©å° */
            #home-button {
                top: max(15px, env(safe-area-inset-top, 0px) + 5px);
                left: max(8px, env(safe-area-inset-left, 0px) + 5px);
                padding: 5px 8px;
                font-size: 10px;
                border-radius: 8px;
                gap: 2px;
            }
            
            #home-button::before {
                font-size: 14px;
            }
        }

        /* åŠ è½½å®¹å™¨æ ·å¼ - ç§»åŠ¨åˆ°å³ä¸‹è§’å¹¶ç¼©å° */
        #loading-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(145deg, rgba(20, 20, 25, 0.95) 0%, rgba(10, 10, 15, 0.98) 100%);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4), 
                        0 0 0 1px rgba(255, 255, 255, 0.05) inset;
            padding: 12px 16px;
            min-width: 250px;
            max-width: 300px;
            z-index: 9999;
            opacity: 1;
            transition: opacity 0.5s ease;
        }

        #loading-container.complete {
            opacity: 0;
            transition: opacity 0.5s ease 0.3s;
        }

        /* åŠ è½½è¿›åº¦æ¡æ ·å¼ - ç¼©å°å°ºå¯¸ */
        #loading-progress {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        #loading-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #8b5cf6, #ec4899);
            background-size: 200% 100%;
            width: 0%;
            border-radius: 6px;
            transition: width 0.3s ease;
            animation: gradient-shift 2s ease-in-out infinite;
        }

        @keyframes gradient-shift {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        /* åŠ è½½çŠ¶æ€æŒ‡ç¤ºå™¨ - é€‚é…å°å‹è¿›åº¦æ¡ */
        #loading-status {
            color: #e5e7eb;
            font-size: 12px;
            font-weight: 500;
            text-align: left;
            opacity: 1;
            transition: opacity 0.3s ease;
        }

        #loading-status.hidden {
            opacity: 0;
            pointer-events: none;
        }

        #loading-status .loading-spinner {
            display: inline-block;
            width: 10px;
            height: 10px;
            border: 1.5px solid rgba(59, 130, 246, 0.3);
            border-top: 1.5px solid #3b82f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 6px;
            vertical-align: middle;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* å“åº”å¼è®¾è®¡ï¼šåœ¨å°å±è®¾å¤‡ä¸Šè°ƒæ•´è¿›åº¦æ¡ä½ç½® */
        @media (max-width: 768px) {
            #loading-container {
                bottom: 10px;
                right: 10px;
                min-width: 200px;
                max-width: 250px;
                padding: 10px 12px;
            }
            
            #loading-status {
                font-size: 11px;
            }
            
            #loading-progress {
                height: 3px;
            }
        }
    </style>
    <script src="config.js"></script>
</head>
<body>
    <!-- åŠ è½½å®¹å™¨ -->
    <div id="loading-container">
        <!-- åŠ è½½è¿›åº¦æ¡ -->
        <div id="loading-progress">
            <div id="loading-progress-bar"></div>
        </div>

        <!-- åŠ è½½çŠ¶æ€æŒ‡ç¤ºå™¨ -->
        <div id="loading-status">
            <span class="loading-spinner"></span>
            <span id="loading-text">æ­£åœ¨åŠ è½½åœ°å›¾...</span>
        </div>
    </div>

    <!-- è¿”å›ä¸»é¡µæŒ‰é’® -->
    <a href="https://www.liyunjian.com" id="home-button" target="_blank">è¿”å›ä¸»é¡µ</a>
    
    <div id="legend-card">
        <div id="legend-title">
            äººç”Ÿå·²æ¢ç´¢åœ°é¢<span style="color:#f59e0b;">è®¡ç®—ä¸­...</span>
            <div style="font-size:0.9em;font-weight:400;color:#9ca3af;margin-top:3px;text-shadow:none;">æ­£åœ¨åˆ†æè½¨è¿¹æ•°æ®</div>
        </div>
        <div id="legend">
            <span style="--glow-color: rgba(239, 68, 68, 0.7); --glow-color-2: rgba(239, 68, 68, 0.5);"><span style="background:#ef4444;"></span>Road</span>
            <span style="--glow-color: rgba(16, 185, 129, 0.7); --glow-color-2: rgba(16, 185, 129, 0.5);"><span style="background:#10b981;"></span>Train</span>
            <span style="--glow-color: rgba(59, 130, 246, 0.7); --glow-color-2: rgba(59, 130, 246, 0.5);"><span style="background:#3b82f6;"></span>Plane</span>
            <span style="--glow-color: rgba(245, 158, 11, 0.7); --glow-color-2: rgba(245, 158, 11, 0.5);"><span style="background:#f59e0b;"></span>Other</span>
        </div>
    </div>
    
    <div id="map"></div>
    
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
    <script src="https://unpkg.com/deck.gl@8.9.0/dist.min.js"></script>
    <script src="https://unpkg.com/@deck.gl/core@8.9.0/dist.min.js"></script>
    <script src="https://unpkg.com/@deck.gl/layers@8.9.0/dist.min.js"></script>
    <script src="https://unpkg.com/@deck.gl/mapbox@8.9.0/dist.min.js"></script>
    <script src="https://unpkg.com/pako@2.1.0/dist/pako.min.js"></script>
    <script>
        // é…ç½®å¸¸é‡
        const CHINA_CENTER = [118.066, 27.86]; // ä¸­å›½å‡ ä½•ä¸­å¿ƒåæ ‡
        const DEFAULT_ZOOM = 5; // åˆå§‹ç¼©æ”¾çº§åˆ«
        const TARGET_ZOOM = 2; // ç›®æ ‡ç¼©æ”¾çº§åˆ«ï¼ˆå…¨çƒè§†å›¾ï¼‰
        
        /**
         * è¿›åº¦æ¡æ§åˆ¶å‡½æ•°
         */
        function updateProgress(percentage, statusText) {
            const progressBar = document.getElementById('loading-progress-bar');
            const statusElement = document.getElementById('loading-text');
            
            if (progressBar) {
                progressBar.style.width = `${Math.min(100, Math.max(0, percentage))}%`;
            }
            
            if (statusElement && statusText) {
                statusElement.textContent = statusText;
            }
        }

        function completeLoading() {
            // è®¾ç½®è¿›åº¦åˆ°100%
            updateProgress(100, 'åŠ è½½å®Œæˆ');
            
            setTimeout(() => {
                // éšè—æ•´ä¸ªåŠ è½½å®¹å™¨
                const loadingContainer = document.getElementById('loading-container');
                
                if (loadingContainer) {
                    loadingContainer.classList.add('complete');
                }
                
                // å®Œå…¨ç§»é™¤å®¹å™¨
                setTimeout(() => {
                    if (loadingContainer) loadingContainer.remove();
                }, 800);
            }, 200);
        }
        
        /**
         * ä»JSONç¼“å­˜åŠ è½½æŒ‡æ ‡æ•°æ®
         */
        async function loadMetrics() {
            console.log('æ­£åœ¨ä»ç¼“å­˜åŠ è½½è®¡ç®—ç»“æœ...');
            
            try {
                const response = await fetch(`cache/metrics.json?t=${Date.now()}`);
                
                if (!response.ok) {
                    throw new Error(`HTTPé”™è¯¯: ${response.status} - ${response.statusText}`);
                }

                const data = await response.json();
                
                // éªŒè¯æ•°æ®æ ¼å¼
                if (typeof data.explored_area_km2 === 'undefined' || 
                    typeof data.earth_percentage === 'undefined') {
                    throw new Error('ç¼“å­˜æ•°æ®æ ¼å¼ä¸æ­£ç¡®');
                }

                console.log('æˆåŠŸåŠ è½½è®¡ç®—ç»“æœ:', data);
                
                return {
                    exploredArea: data.explored_area_km2,
                    percentage: data.earth_percentage,
                    totalFiles: data.total_files,
                    totalPoints: data.total_points,
                    uniquePoints: data.unique_points,
                    calculationTime: data.calculation_time,
                    files: data.files
                };

            } catch (error) {
                console.error('åŠ è½½ç¼“å­˜å¤±è´¥:', error);
                
                let errorMessage;
                if (error.message.includes('404') || error.message.includes('HTTPé”™è¯¯')) {
                    errorMessage = 'ç¼“å­˜æ–‡ä»¶ä¸å­˜åœ¨ï¼Œè¯·å…ˆè¿è¡Œ calculate_metrics.py ç”Ÿæˆç¼“å­˜';
                } else if (error.message.includes('æ ¼å¼ä¸æ­£ç¡®')) {
                    errorMessage = 'ç¼“å­˜æ–‡ä»¶æ ¼å¼é”™è¯¯ï¼Œè¯·é‡æ–°ç”Ÿæˆç¼“å­˜';
                } else {
                    errorMessage = 'åŠ è½½ç¼“å­˜æ—¶å‘ç”ŸæœªçŸ¥é”™è¯¯: ' + error.message;
                }
                
                return {
                    exploredArea: 0,
                    percentage: 0,
                    totalFiles: 0,
                    totalPoints: 0,
                    uniquePoints: 0,
                    calculationTime: null,
                    files: [],
                    error: errorMessage
                };
            }
        }

        // å…¨å±€å˜é‡
        let dataWorker = null;
        let messageIdCounter = 0;
        let pendingMessages = new Map();
        let currentTracksData = null;
        let isProgressiveMode = false;

        /**
         * åˆå§‹åŒ– Data Worker
         */
        function initializeDataWorker() {
            if (!dataWorker) {
                try {
                    dataWorker = new Worker('data-worker.js');
                    dataWorker.addEventListener('message', handleWorkerMessage);
                    console.log('âœ… Data Worker åˆå§‹åŒ–æˆåŠŸ');
                } catch (error) {
                    console.warn('âš ï¸ Data Worker åˆå§‹åŒ–å¤±è´¥ï¼Œå›é€€åˆ°ä¸»çº¿ç¨‹æ¨¡å¼:', error);
                    dataWorker = null;
                }
            }
        }

        /**
         * å¤„ç† Worker æ¶ˆæ¯
         */
        function handleWorkerMessage(e) {
            const { type, messageId, data, success, error } = e.data;
            
            if (pendingMessages.has(messageId)) {
                const { resolve, reject } = pendingMessages.get(messageId);
                pendingMessages.delete(messageId);
                
                if (success) {
                    resolve(data);
                } else {
                    reject(new Error(error));
                }
            }
        }

        /**
         * å‘é€æ¶ˆæ¯ç»™ Worker
         */
        function sendWorkerMessage(type, data) {
            return new Promise((resolve, reject) => {
                if (!dataWorker) {
                    reject(new Error('Data Worker æœªåˆå§‹åŒ–'));
                    return;
                }
                
                const messageId = ++messageIdCounter;
                pendingMessages.set(messageId, { resolve, reject });
                
                dataWorker.postMessage({
                    type,
                    messageId,
                    data
                });
            });
        }

        /**
         * ä½¿ç”¨ Worker å¤„ç†è½¨è¿¹æ•°æ®
         */
        async function processTrackDataWithWorker(arrayBuffer, isGzip = true, optimize = true) {
            if (!dataWorker) {
                // å›é€€åˆ°ä¸»çº¿ç¨‹å¤„ç†
                return processTrackDataMainThread(arrayBuffer, isGzip, optimize);
            }
            
            try {
                return await sendWorkerMessage('PROCESS_TRACK_DATA', {
                    arrayBuffer,
                    isGzip,
                    optimize
                });
            } catch (error) {
                console.warn('Worker å¤„ç†å¤±è´¥ï¼Œå›é€€åˆ°ä¸»çº¿ç¨‹:', error);
                return processTrackDataMainThread(arrayBuffer, isGzip, optimize);
            }
        }

        /**
         * ä¸»çº¿ç¨‹å¤„ç†è½¨è¿¹æ•°æ®ï¼ˆå›é€€æ–¹æ¡ˆï¼‰
         */
        function processTrackDataMainThread(arrayBuffer, isGzip = true, optimize = true) {
            let data;
            
            if (isGzip) {
                if (typeof pako !== 'undefined') {
                    const compressedData = new Uint8Array(arrayBuffer);
                    const decompressedData = pako.inflate(compressedData, { to: 'string' });
                    data = JSON.parse(decompressedData);
                } else {
                    throw new Error('Pako åº“æœªåŠ è½½ï¼Œæ— æ³•è§£å‹ gzip æ•°æ®');
                }
            } else {
                const textDecoder = new TextDecoder();
                const jsonString = textDecoder.decode(arrayBuffer);
                data = JSON.parse(jsonString);
            }
            
            if (optimize) {
                // ç®€åŒ–æ•°æ®ç»“æ„ä¼˜åŒ–
                const optimized = { ...data };
                if (data.tracks) {
                    Object.entries(data.tracks).forEach(([trackType, trackData]) => {
                        if (trackData.points && trackData.points.features) {
                            optimized.tracks[trackType].points.features = trackData.points.features.map(f => ({
                                geometry: { coordinates: f.geometry.coordinates },
                                properties: f.properties ? { timestamp: f.properties.timestamp } : {}
                            }));
                        }
                    });
                }
                return optimized;
            }
            
            return data;
        }

        /**
         * ä»JSONç¼“å­˜åŠ è½½è½¨è¿¹æ•°æ®ï¼ˆä¼˜åŒ–ç‰ˆæœ¬ï¼Œæ”¯æŒæ¸è¿›å¼åŠ è½½ï¼‰
         */
        async function loadTracksData() {
            console.log('æ­£åœ¨ä»ç¼“å­˜åŠ è½½è½¨è¿¹æ•°æ®...');

            try {
                // åˆå§‹åŒ– Worker
                initializeDataWorker();
                
                // å…ˆåŠ è½½é™æ€é…ç½®æ–‡ä»¶ï¼Œç¡®å®šæ•°æ®ç»“æ„
                console.log('æ­£åœ¨è¯»å–é™æ€é…ç½®æ–‡ä»¶...');
                const configResponse = await fetch(`cache/data_config.json?t=${Date.now()}`);
                
                if (!configResponse.ok) {
                    throw new Error(`é…ç½®æ–‡ä»¶åŠ è½½å¤±è´¥: ${configResponse.status}`);
                }

                const config = await configResponse.json();
                console.log('é…ç½®æ–‡ä»¶åŠ è½½æˆåŠŸ:', config);

                if (config.data_type === 'single') {
                    // å•ä¸ªæ–‡ä»¶æ¨¡å¼ï¼ˆä½¿ç”¨ Worker ä¼˜åŒ–ï¼‰
                    console.log('æ£€æµ‹åˆ°å•ä¸ªæ–‡ä»¶æ¨¡å¼ï¼Œä½¿ç”¨ Worker ä¼˜åŒ–å¤„ç†...');
                    const response = await fetch(`cache/${config.single_file}?t=${Date.now()}`);
                    
                    if (!response.ok) {
                        throw new Error(`æ•°æ®æ–‡ä»¶åŠ è½½å¤±è´¥: ${response.status}`);
                    }

                    const arrayBuffer = await response.arrayBuffer();
                    const isGzip = config.format === 'gzip' || config.single_file.endsWith('.gz');
                    
                    console.log('å¼€å§‹è§£å‹å’Œä¼˜åŒ–æ•°æ®...');
                    const data = await processTrackDataWithWorker(arrayBuffer, isGzip, true);
                    
                    console.log('æˆåŠŸåŠ è½½å¹¶ä¼˜åŒ–å•ä¸ªè½¨è¿¹æ–‡ä»¶:', {
                        trackTypes: Object.keys(data.tracks),
                        totalTracks: Object.values(data.tracks).reduce((sum, track) => sum + (track.points_count || 0), 0),
                        bounds: data.bounds,
                        format: config.format || 'json',
                        fileSize: (arrayBuffer.byteLength / 1024 / 1024).toFixed(2) + ' MB'
                    });
                    
                    return data;
                    
                } else if (config.data_type === 'chunked') {
                    // åˆ†ç‰‡æ–‡ä»¶æ¨¡å¼ï¼ˆæ¸è¿›å¼åŠ è½½ï¼‰
                    console.log(`æ£€æµ‹åˆ°åˆ†ç‰‡æ–‡ä»¶æ¨¡å¼ï¼Œå…± ${config.chunks.length} ä¸ªåˆ†ç‰‡ï¼Œå¯ç”¨æ¸è¿›å¼åŠ è½½...`);
                    isProgressiveMode = true;

                    let mergedData = {
                        metrics: null,
                        tracks: {},
                        bounds: null,
                        generated_at: null,
                        version: null,
                        chunked: true,
                        total_chunks: config.chunks.length
                    };

                    // æ¸è¿›å¼åŠ è½½æ¯ä¸ªåˆ†ç‰‡
                    for (let i = 0; i < config.chunks.length; i++) {
                        const chunkFile = config.chunks[i];
                        console.log(`æ­£åœ¨åŠ è½½åˆ†ç‰‡ ${i + 1}/${config.chunks.length}: ${chunkFile}`);
                        
                        const chunkResponse = await fetch(`cache/${chunkFile}?t=${Date.now()}`);
                        if (!chunkResponse.ok) {
                            throw new Error(`åˆ†ç‰‡æ–‡ä»¶åŠ è½½å¤±è´¥: ${chunkFile}`);
                        }
                        
                        let chunk;
                        const isGzip = config.format === 'gzip' || chunkFile.endsWith('.gz');
                        
                        if (isGzip) {
                            // å¤„ç† gzip åˆ†ç‰‡æ–‡ä»¶
                            console.log(`è§£å‹åˆ†ç‰‡ ${i + 1}: ${chunkFile} (å¤§å°: ${chunkResponse.headers.get('content-length') || 'æœªçŸ¥'} å­—èŠ‚)`);
                            try {
                                const arrayBuffer = await chunkResponse.arrayBuffer();
                                console.log(`ArrayBuffer å¤§å°: ${arrayBuffer.byteLength} å­—èŠ‚`);
                                chunk = await processTrackDataWithWorker(arrayBuffer, true, false); // åˆ†ç‰‡å·²ç»ä¼˜åŒ–è¿‡äº†
                                console.log(`è§£å‹å®Œæˆï¼Œæ•°æ®ç±»å‹:`, typeof chunk, chunk ? Object.keys(chunk) : 'null');
                                
                                if (!chunk) {
                                    throw new Error('Worker è¿”å›ç©ºæ•°æ®');
                                }
                            } catch (workerError) {
                                console.warn('Worker å¤„ç†å¤±è´¥ï¼Œå°è¯•ä¸»çº¿ç¨‹å¤„ç†:', workerError);
                                const arrayBuffer = await chunkResponse.arrayBuffer();
                                chunk = processTrackDataMainThread(arrayBuffer, true, false);
                            }
                        } else {
                            // å¤„ç† JSON åˆ†ç‰‡æ–‡ä»¶
                            chunk = await chunkResponse.json();
                        }

                        // æ·»åŠ æ•°æ®å®Œæ•´æ€§æ£€æŸ¥
                        console.log(`\n=== å¤„ç†åˆ†ç‰‡ ${i + 1}/${config.chunks.length} ===`);
                        console.log('åˆ†ç‰‡æ•°æ®ç»“æ„:', {
                            hasMetadata: !!chunk.metadata,
                            hasMetrics: !!chunk.metrics,
                            hasBounds: !!chunk.bounds,
                            hasTracks: !!chunk.tracks,
                            trackTypes: chunk.tracks ? Object.keys(chunk.tracks) : [],
                            trackCounts: chunk.tracks ? Object.fromEntries(
                                Object.keys(chunk.tracks).map(type => [
                                    type, 
                                    {
                                        points: chunk.tracks[type]?.points_count || chunk.tracks[type]?.points?.features?.length || 0,
                                        lines: chunk.tracks[type]?.lines_count || chunk.tracks[type]?.lines?.features?.length || 0
                                    }
                                ])
                            ) : {}
                        });

                        // åˆå¹¶åˆ†ç‰‡æ•°æ®
                        if (!chunk || !chunk.tracks) {
                            console.warn(`åˆ†ç‰‡ ${i + 1} æ•°æ®æ— æ•ˆï¼Œè·³è¿‡`);
                            continue;
                        }
                        
                        if (i === 0) {
                            mergedData.metrics = chunk.metrics;
                            mergedData.bounds = chunk.bounds;
                            mergedData.generated_at = chunk.generated_at;
                            mergedData.version = chunk.version;
                        }
                        
                        Object.keys(chunk.tracks).forEach(trackType => {
                            if (chunk.tracks[trackType]) {
                                // æ™ºèƒ½åˆå¹¶è½¨è¿¹æ•°æ®
                                if (!mergedData.tracks[trackType]) {
                                    // å¦‚æœè½¨è¿¹ç±»å‹è¿˜ä¸å­˜åœ¨ï¼Œç›´æ¥å¤åˆ¶
                                    mergedData.tracks[trackType] = chunk.tracks[trackType];
                                    console.log(`æ–°å¢è½¨è¿¹ç±»å‹: ${trackType}`);
                                } else {
                                    // å¦‚æœè½¨è¿¹ç±»å‹å·²å­˜åœ¨ï¼Œéœ€è¦åˆå¹¶æ•°æ®
                                    const existingTrack = mergedData.tracks[trackType];
                                    const newTrack = chunk.tracks[trackType];
                                    
                                    // åˆå¹¶ç‚¹æ•°æ®
                                    if (newTrack.points && newTrack.points.features) {
                                        if (!existingTrack.points) {
                                            existingTrack.points = { features: [] };
                                        }
                                        existingTrack.points.features.push(...newTrack.points.features);
                                        existingTrack.points_count = existingTrack.points.features.length;
                                        console.log(`åˆå¹¶ ${trackType} ç‚¹æ•°æ®: +${newTrack.points.features.length} = ${existingTrack.points_count}`);
                                    }
                                    
                                    // åˆå¹¶çº¿æ•°æ®
                                    if (newTrack.lines && newTrack.lines.features) {
                                        if (!existingTrack.lines) {
                                            existingTrack.lines = { features: [] };
                                        }
                                        existingTrack.lines.features.push(...newTrack.lines.features);
                                        existingTrack.lines_count = existingTrack.lines.features.length;
                                        console.log(`åˆå¹¶ ${trackType} çº¿æ•°æ®: +${newTrack.lines.features.length} = ${existingTrack.lines_count}`);
                                    }
                                }
                            }
                        });

                        // æ¯åŠ è½½ä¸€ä¸ªåˆ†ç‰‡å°±æ¸è¿›å¼æ¸²æŸ“
                        if (window.mapInstance) {
                            console.log(`æ¸è¿›å¼æ¸²æŸ“åˆ†ç‰‡ ${i + 1}...`);
                            console.log(`å½“å‰åˆå¹¶æ•°æ®åŒ…å«è½¨è¿¹ç±»å‹:`, Object.keys(mergedData.tracks));
                            
                            // ç»Ÿè®¡å½“å‰æ•°æ®é‡
                            const currentStats = {};
                            Object.entries(mergedData.tracks).forEach(([type, data]) => {
                                currentStats[type] = {
                                    points: data.points_count || 0,
                                    lines: data.lines_count || 0
                                };
                            });
                            console.log(`å½“å‰æ•°æ®ç»Ÿè®¡:`, currentStats);
                            
                            renderTracks(window.mapInstance, mergedData, true); // progressive = true
                        }

                        // æ›´æ–°è¿›åº¦
                        updateProgress(40 + Math.floor(30 * (i + 1) / config.chunks.length), 
                                     `å·²åŠ è½½å¹¶æ¸²æŸ“åˆ†ç‰‡ ${i + 1}/${config.chunks.length}`);
                    }

                    console.log('\nğŸ‰ æˆåŠŸåˆå¹¶æ‰€æœ‰åˆ†ç‰‡æ•°æ®!');
                    console.log('ğŸ“Š æœ€ç»ˆæ•°æ®ç»Ÿè®¡:', {
                        trackTypes: Object.keys(mergedData.tracks),
                        totalChunks: mergedData.total_chunks,
                        bounds: mergedData.bounds,
                        trackCounts: Object.fromEntries(
                            Object.keys(mergedData.tracks).map(type => [
                                type, 
                                {
                                    points: mergedData.tracks[type]?.points_count || 0,
                                    lines: mergedData.tracks[type]?.lines_count || 0
                                }
                            ])
                        )
                    });
                    
                    return mergedData;
                    
                } else {
                    throw new Error(`æœªçŸ¥çš„æ•°æ®ç±»å‹: ${config.data_type}`);
                }

            } catch (error) {
                console.error('åŠ è½½è½¨è¿¹æ•°æ®å¤±è´¥:', error);
                console.error('é”™è¯¯è¯¦æƒ…:', {
                    message: error.message,
                    stack: error.stack
                });
                return null;
            }
        }
        
        /**
         * è°ƒè¯•å·¥å…·ï¼šæ£€æŸ¥æ•°æ®å®Œæ•´æ€§
         */
        function debugDataCompleteness(data) {
            console.group('ğŸ” æ•°æ®å®Œæ•´æ€§æ£€æŸ¥');
            
            if (!data || !data.tracks) {
                console.error('âŒ æ•°æ®æ— æ•ˆæˆ–ç¼ºå°‘è½¨è¿¹æ•°æ®');
                console.groupEnd();
                return false;
            }
            
            const trackTypes = Object.keys(data.tracks);
            console.log('ğŸ“‹ è½¨è¿¹ç±»å‹:', trackTypes);
            
            let totalPoints = 0;
            let totalLines = 0;
            
            trackTypes.forEach(trackType => {
                const track = data.tracks[trackType];
                const pointCount = track.points_count || (track.points?.features?.length || 0);
                const lineCount = track.lines_count || (track.lines?.features?.length || 0);
                
                console.log(`${trackType}:`, {
                    points: pointCount,
                    lines: lineCount,
                    hasPointsData: !!(track.points && track.points.features),
                    hasLinesData: !!(track.lines && track.lines.features)
                });
                
                totalPoints += pointCount;
                totalLines += lineCount;
            });
            
            console.log('ğŸ“Š æ€»è®¡:', {
                totalPoints,
                totalLines,
                trackTypes: trackTypes.length,
                isChunked: data.chunked || false,
                totalChunks: data.total_chunks || 1
            });
            
            console.groupEnd();
            return true;
        }

        /**
         * æ›´æ–°å›¾ä¾‹æ ‡é¢˜æ˜¾ç¤º
         */
        function updateLegendTitle(metrics) {
            const titleEl = document.querySelector('#legend-title');
            if (!titleEl) return;
            
            const spanEl = titleEl.querySelector('span');
            const divEl = titleEl.querySelector('div');
            
            if (metrics.error) {
                spanEl.innerHTML = '<span style="color:#ef4444;">æœªæ‰¾åˆ°ç¼“å­˜</span>';
                divEl.innerHTML = `<small style="color:#94a3b8;">${metrics.error}</small>`;
            } else {
                spanEl.textContent = `${metrics.exploredArea.toFixed(6)}kmÂ²`;
                divEl.textContent = `æ˜¯åœ°çƒçš„${metrics.percentage.toFixed(15)}%`;
                
                // åœ¨æ§åˆ¶å°æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯
                if (metrics.totalFiles) {
                    console.log('ğŸ“Š æ¢ç´¢æ•°æ®è¯¦æƒ…:');
                    console.log(`   æ–‡ä»¶æ•°é‡: ${metrics.totalFiles}`);
                    console.log(`   æ€»è½¨è¿¹ç‚¹: ${metrics.totalPoints}`);
                    console.log(`   å»é‡å: ${metrics.uniquePoints}`);
                    console.log(`   è®¡ç®—æ—¶é—´: ${metrics.calculationTime || 'æœªçŸ¥'}`);
                }
            }
        }
        
        /**
         * æ ¹æ®è½¨è¿¹èŒƒå›´è®¡ç®—åˆé€‚çš„ç¼©æ”¾çº§åˆ«
         */
        function calculateZoomLevel(bounds) {
            const lngSpan = bounds.max_lng - bounds.min_lng;
            const latSpan = bounds.max_lat - bounds.min_lat;
            const maxSpan = Math.max(lngSpan, latSpan);
            
            if (maxSpan > 40) return 2.5;      // è·¨æ´²é™…è½¨è¿¹
            else if (maxSpan > 30) return 3.0; // è·¨å›½è½¨è¿¹  
            else if (maxSpan > 20) return 3.5; // å¤§èŒƒå›´å›½å†…è½¨è¿¹
            else if (maxSpan > 10) return 4.2; // ä¸­èŒƒå›´è½¨è¿¹
            else if (maxSpan > 5) return 5.0;  // å°èŒƒå›´è½¨è¿¹
            else return 6.0;                   // æœ¬åœ°è½¨è¿¹
        }
        
        /**
         * æ¸²æŸ“è½¨è¿¹æ•°æ®åˆ°åœ°å›¾ï¼ˆä¼˜åŒ–ç‰ˆæœ¬ï¼Œæ”¯æŒè™šæ‹ŸåŒ–æ¸²æŸ“ï¼‰
         */
        function renderTracks(map, tracksData, progressive = false) {
            console.log('å¼€å§‹ç”¨ deck.gl æ¸²æŸ“è½¨è¿¹...', { progressive });
            
            if (!tracksData || !tracksData.tracks) {
                console.error('è½¨è¿¹æ•°æ®æ— æ•ˆ:', tracksData);
                return;
            }

            try {
                const layers = [];
                const currentZoom = map.getZoom();
                const mapBounds = map.getBounds();
                
                // ç”Ÿæˆå”¯ä¸€æ ‡è¯†ç¬¦ç”¨äºåŒºåˆ†åˆ†ç‰‡
                const renderSessionId = progressive ? `chunk_${Date.now()}_${Math.random().toString(36).substr(2, 9)}` : 'main';
                
                // è·å–è§†çª—è¾¹ç•Œ
                const bounds = {
                    west: mapBounds.getWest(),
                    east: mapBounds.getEast(),
                    south: mapBounds.getSouth(),
                    north: mapBounds.getNorth()
                };
                
                console.log('å½“å‰ç¼©æ”¾çº§åˆ«:', currentZoom, 'è§†çª—è¾¹ç•Œ:', bounds, 'æ¸²æŸ“ä¼šè¯:', renderSessionId);
            
            Object.entries(tracksData.tracks).forEach(([trackType, trackData]) => {
                if (!trackData) {
                    console.warn(`è½¨è¿¹ç±»å‹ ${trackType} æ•°æ®ä¸ºç©º`);
                    return;
                }
                
                const color = trackData.color || '#3b82f6';
                const displayType = trackData.display_type || '';
                const colorRgb = colorToRgb(color);
                
                console.log(`å¤„ç†è½¨è¿¹ç±»å‹: ${trackType}, é¢œè‰²: ${color}, æ˜¾ç¤ºç±»å‹: ${displayType}`);
                
                // æ¸²æŸ“ç‚¹æ•°æ®
                if (displayType === 'points' && trackData.points && Array.isArray(trackData.points.features)) {
                    let pointFeatures = trackData.points.features;
                    
                    // è™šæ‹ŸåŒ–æ¸²æŸ“ï¼šæ ¹æ®ç¼©æ”¾çº§åˆ«å’Œè§†çª—è¿‡æ»¤ç‚¹
                    if (currentZoom < 6) {
                        // ä½ç¼©æ”¾çº§åˆ«æ—¶è¿›è¡Œé‡‡æ ·ä»¥æé«˜æ€§èƒ½
                        const sampleRate = currentZoom < 4 ? 0.05 : 0.2;
                        // ä½¿ç”¨ç¡®å®šæ€§é‡‡æ ·è€Œä¸æ˜¯éšæœºé‡‡æ ·ï¼Œä¿è¯ç»“æœä¸€è‡´
                        pointFeatures = pointFeatures.filter((_, index) => 
                            (index % Math.ceil(1 / sampleRate)) === 0
                        );
                        console.log(`${trackType} ç‚¹æ•°æ®é‡‡æ ·: ${pointFeatures.length}/${trackData.points.features.length}`);
                    }
                    
                    // è§†çª—è¿‡æ»¤
                    pointFeatures = pointFeatures.filter(feature => {
                        if (!feature || !feature.geometry || !feature.geometry.coordinates) return false;
                        const coords = feature.geometry.coordinates;
                        if (!Array.isArray(coords) || coords.length < 2) return false;
                        const [lng, lat] = coords;
                        if (typeof lng !== 'number' || typeof lat !== 'number') return false;
                        return lng >= bounds.west && lng <= bounds.east && 
                               lat >= bounds.south && lat <= bounds.north;
                    });
                    
                    if (pointFeatures.length > 0) {
                        const layerId = progressive ? 
                            `${trackType}-points-${renderSessionId}` : 
                            `${trackType}-points-layer`;
                            
                        layers.push(new deck.ScatterplotLayer({
                            id: layerId,
                            data: pointFeatures,
                            getPosition: f => Array.isArray(f.geometry.coordinates) ? f.geometry.coordinates : [0,0],
                            getRadius: Math.max(1000, 5000 / Math.pow(2, currentZoom - 2)),
                            getFillColor: colorRgb,
                            opacity: 1,
                            radiusMinPixels: 0.6,
                            radiusMaxPixels: 1.7,
                            updateTriggers: {
                                getRadius: currentZoom,
                                getFillColor: color
                            },
                            transitions: {
                                getRadius: 300,
                                getFillColor: 300
                            },
                            pickable: false // ç¦ç”¨ç‚¹å‡»ä»¥æé«˜æ€§èƒ½
                        }));
                        console.log(`âœ… ${trackType} æ¸²æŸ“ ${pointFeatures.length} ä¸ªç‚¹`);
                    }
                }
                
                // æ¸²æŸ“çº¿æ•°æ®
                if (displayType === 'lines' && trackData.lines && Array.isArray(trackData.lines.features)) {
                    let lineFeatures = trackData.lines.features;
                    
                    // è§†çª—è¿‡æ»¤çº¿æ®µ
                    lineFeatures = lineFeatures.filter(feature => {
                        if (!feature || !feature.geometry || !feature.geometry.coordinates) return false;
                        const coords = feature.geometry.coordinates;
                        if (!Array.isArray(coords)) return false;
                        // æ£€æŸ¥çº¿æ®µæ˜¯å¦ä¸è§†çª—ç›¸äº¤
                        return coords.some(coord => {
                            if (!Array.isArray(coord) || coord.length < 2) return false;
                            const [lng, lat] = coord;
                            if (typeof lng !== 'number' || typeof lat !== 'number') return false;
                            return lng >= bounds.west && lng <= bounds.east && 
                                   lat >= bounds.south && lat <= bounds.north;
                        });
                    });
                    
                    if (lineFeatures.length > 0) {
                        const layerId = progressive ? 
                            `${trackType}-lines-${renderSessionId}` : 
                            `${trackType}-lines-layer`;
                            
                        layers.push(new deck.PathLayer({
                            id: layerId,
                            data: lineFeatures,
                            getPath: f => f.geometry.coordinates,
                            getWidth: Math.max(2, 8 / Math.pow(2, Math.max(0, currentZoom - 6))),
                            getColor: colorRgb,
                            opacity: 0.9,
                            widthMinPixels: 2,
                            widthMaxPixels: 10,
                            capRounded: true,
                            jointRounded: true,
                            updateTriggers: {
                                getWidth: currentZoom,
                                getColor: color
                            },
                            transitions: {
                                getWidth: 300,
                                getColor: 300
                            },
                            pickable: false // ç¦ç”¨ç‚¹å‡»ä»¥æé«˜æ€§èƒ½
                        }));
                        console.log(`âœ… ${trackType} æ¸²æŸ“ ${lineFeatures.length} æ¡çº¿æ®µ`);
                    }
                }
            });

            console.log(`æ€»å…±åˆ›å»ºäº† ${layers.length} ä¸ªå›¾å±‚`);

            // ç®¡ç† deck.gl å›¾å±‚
            if (!window.deckOverlay) {
                window.deckOverlay = new deck.MapboxOverlay({ 
                    layers,
                    // æ€§èƒ½ä¼˜åŒ–é…ç½®
                    getTooltip: null, // ç¦ç”¨ tooltip ä»¥æé«˜æ€§èƒ½
                    pickingRadius: 0  // ç¦ç”¨ç‚¹å‡»äº‹ä»¶ä»¥æé«˜æ€§èƒ½
                });
                map.addControl(window.deckOverlay);
                console.log('âœ… æ–°å»º deck.gl overlay');
            } else {
                // æ¸è¿›å¼æ›´æ–°æˆ–å®Œå…¨æ›´æ–°
                if (progressive) {
                    // æ¸è¿›å¼æ¨¡å¼ï¼šç´¯ç§¯æ·»åŠ å›¾å±‚ï¼Œé¿å…è¦†ç›–
                    const existingLayers = (window.deckOverlay && window.deckOverlay.props && window.deckOverlay.props.layers) || [];
                    
                    // ä½¿ç”¨æ›´æ™ºèƒ½çš„å›¾å±‚åˆå¹¶ç­–ç•¥
                    const existingLayerMap = new Map();
                    existingLayers.forEach(layer => {
                        existingLayerMap.set(layer.id, layer);
                    });
                    
                    // æ·»åŠ æˆ–æ›´æ–°æ–°å›¾å±‚
                    layers.forEach(layer => {
                        existingLayerMap.set(layer.id, layer);
                    });
                    
                    const allLayers = Array.from(existingLayerMap.values());
                    window.deckOverlay.setProps({ layers: allLayers });
                    
                    console.log(`âœ… æ¸è¿›å¼æ›´æ–°å›¾å±‚: ${existingLayers.length} + ${layers.length} = ${allLayers.length} ä¸ªå›¾å±‚`);
                } else {
                    // å®Œå…¨æ›¿æ¢å›¾å±‚
                    window.deckOverlay.setProps({ layers });
                    console.log('âœ… å®Œå…¨æ›´æ–°å›¾å±‚');
                }
            }
            
            console.log('âœ… deck.gl è½¨è¿¹æ¸²æŸ“å®Œæˆ');
            
            } catch (error) {
                console.error('æ¸²æŸ“è½¨è¿¹æ—¶å‘ç”Ÿé”™è¯¯:', error);
                console.error('é”™è¯¯è¯¦æƒ…:', {
                    message: error.message,
                    stack: error.stack,
                    tracksData: tracksData ? Object.keys(tracksData) : 'null'
                });
            }
        }

        // é¢œè‰²å­—ç¬¦ä¸²è½¬ RGB æ•°ç»„
        function colorToRgb(hex, alpha=255) {
            // æ”¯æŒ #rrggbb æˆ– rgb()
            if (hex.startsWith('#')) {
                const bigint = parseInt(hex.slice(1), 16);
                return [(bigint>>16)&255, (bigint>>8)&255, bigint&255, alpha];
            } else if (hex.startsWith('rgb')) {
                const arr = hex.match(/\d+/g).map(Number);
                return [...arr, alpha];
            }
            return [59,130,246,alpha]; // é»˜è®¤è“è‰²
        }
        
        /**
         * è°ƒæ•´åœ°å›¾è§†å›¾åˆ°åˆé€‚ä½ç½®
         */
        function adjustMapView(map, tracksData) {
            // æ‰§è¡Œç¼©æ”¾åŠ¨ç”»ï¼Œä»4åˆ°2ï¼Œä½†ä¿æŒä¸­å¿ƒä½ç½®ä¸å˜
            console.log('æ‰§è¡Œç¼©æ”¾åŠ¨ç”»ï¼šä»çº§åˆ«4åˆ°çº§åˆ«2ï¼Œä¿æŒä¸­å›½å±…ä¸­');
            setTimeout(() => {
                map.flyTo({
                    center: CHINA_CENTER,  // ä¿æŒä¸­å¿ƒä½ç½®ä¸å˜
                    zoom: TARGET_ZOOM,     // ç¼©æ”¾åˆ°å…¨çƒè§†å›¾
                    duration: 1000,        // 2ç§’åŠ¨ç”»æ—¶é•¿
                    curve: 0.2,              // çº¿æ€§ç¼©æ”¾æ›²çº¿
                    easing: (t) => t       // çº¿æ€§ç¼“åŠ¨ï¼Œé¿å…è½¬åŠ¨æ•ˆæœ
                });
            }, 30);
        }

        // åˆå§‹åŒ–è¿›åº¦æ¡
        updateProgress(0, 'æ­£åœ¨åˆå§‹åŒ–...');

        // åˆå§‹åŒ–åœ°å›¾
        mapboxgl.accessToken = window.CONFIG.MAPBOX_ACCESS_TOKEN;
        
        updateProgress(10, 'æ­£åœ¨åŠ è½½åœ°å›¾...');
        
        const map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/yunjian/cmfxy24sw000j01s7354u3hqh',
            center: CHINA_CENTER,
            zoom: DEFAULT_ZOOM,
            minZoom: 2,    // å¯ä»¥ç¼©å°åˆ°å…¨çƒè§†å›¾
            maxZoom: 11,   // é™åˆ¶æœ€å¤§æ”¾å¤§å€æ•°
            projection: 'mercator' // åˆå§‹åŒ–æ—¶å°±è®¾ç½®ä¸ºå¹³é¢æŠ•å½±ï¼Œé¿å…åæœŸåˆ‡æ¢é€ æˆé—ªçƒ
        });

        // åœ°å›¾åŠ è½½å®Œæˆåçš„å¤„ç†
        map.on('load', function() {
            updateProgress(20, 'åœ°å›¾åŠ è½½å®Œæˆï¼Œå¼€å§‹è·å–æ•°æ®...');
            
            // ä¿å­˜åœ°å›¾å®ä¾‹åˆ°å…¨å±€å˜é‡ï¼Œä¾›æ¸è¿›å¼åŠ è½½ä½¿ç”¨
            window.mapInstance = map;
            
            // å¹¶è¡ŒåŠ è½½æ•°æ®
            Promise.all([
                loadMetrics().then(result => {
                    updateProgress(40, 'æŒ‡æ ‡æ•°æ®åŠ è½½å®Œæˆ...');
                    return result;
                }),
                loadTracksData().then(result => {
                    updateProgress(70, 'è½¨è¿¹æ•°æ®åŠ è½½å®Œæˆ...');
                    return result;
                })
            ]).then(([metrics, tracksData]) => {
                updateProgress(80, 'æ­£åœ¨æ¸²æŸ“è½¨è¿¹...');
                
                // æ›´æ–°UIæ˜¾ç¤º
                updateLegendTitle(metrics);
                
                // æ¸²æŸ“è½¨è¿¹æ•°æ®
                if (tracksData) {
                    // åœ¨æ¸²æŸ“å‰è¿›è¡Œæ•°æ®å®Œæ•´æ€§æ£€æŸ¥
                    console.log('ğŸ“ å‡†å¤‡æ¸²æŸ“è½¨è¿¹æ•°æ®...');
                    debugDataCompleteness(tracksData);
                    
                    renderTracks(map, tracksData);
                    currentTracksData = tracksData; // ä¿å­˜å½“å‰è½¨è¿¹æ•°æ®
                }
                
                updateProgress(95, 'æ­£åœ¨å®Œæˆæœ€åè®¾ç½®...');
                
                // å®ŒæˆåŠ è½½
                setTimeout(() => {
                    completeLoading();
                }, 500);
                
            }).catch(error => {
                console.error('æ•°æ®åŠ è½½å¤±è´¥:', error);
                updateProgress(100, 'åŠ è½½å¤±è´¥');
                
                // æ˜¾ç¤ºé”™è¯¯çŠ¶æ€
                const titleEl = document.querySelector('#legend-title');
                if (titleEl) {
                    titleEl.querySelector('span').innerHTML = '<span style="color:#ef4444;">åŠ è½½å¤±è´¥</span>';
                    titleEl.querySelector('div').textContent = 'è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥';
                }
                
                // å»¶è¿Ÿéšè—è¿›åº¦æ¡
                setTimeout(() => {
                    completeLoading();
                }, 2000);
            });
        });

        // æ·»åŠ åœ°å›¾äº¤äº’ç›‘å¬å™¨ï¼Œå®ç°åŠ¨æ€è™šæ‹ŸåŒ–æ¸²æŸ“
        let renderTimeout;
        map.on('moveend', function() {
            // é˜²æŠ–å¤„ç†ï¼Œé¿å…é¢‘ç¹é‡æ¸²æŸ“
            if (renderTimeout) clearTimeout(renderTimeout);
            renderTimeout = setTimeout(() => {
                if (currentTracksData && window.deckOverlay) {
                    console.log('åœ°å›¾ç§»åŠ¨å®Œæˆï¼Œé‡æ–°æ¸²æŸ“å¯è§åŒºåŸŸè½¨è¿¹...');
                    renderTracks(map, currentTracksData);
                }
            }, 200);
        });

        map.on('zoomend', function() {
            // é˜²æŠ–å¤„ç†ï¼Œé¿å…é¢‘ç¹é‡æ¸²æŸ“
            if (renderTimeout) clearTimeout(renderTimeout);
            renderTimeout = setTimeout(() => {
                if (currentTracksData && window.deckOverlay) {
                    console.log('ç¼©æ”¾å®Œæˆï¼Œæ ¹æ®æ–°ç¼©æ”¾çº§åˆ«é‡æ–°æ¸²æŸ“è½¨è¿¹...');
                    renderTracks(map, currentTracksData);
                }
            }, 200);
        });
    </script>
</body>
</html>
